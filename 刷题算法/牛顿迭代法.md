# 牛顿迭代法

## 求近似解

### 概念

**牛顿法**又称为**牛顿-拉弗森方法**，它是一种在实数域和复数域上近似求解方程的方法。方法使用函数$f(x)$的泰勒级数的前面几项来寻找方程$f(x)=0$的根。

==注意：==牛顿法只能逼近解，不能计算精确解。 

### 原理

利用泰勒公式，在$x_0$处展开，展开到一阶，即：
$$
f(x)=f(x_0)-f^{'}(x_0)(x-x_0) \tag{1}
$$
令$f(x)=0$，就是我们要找的方程的解，即：
$$
x_1=x_0-\frac{f(x_0)}{f^{'}(x_0)} \tag{2}
$$
同理，在$x_1$处展开，则：
$$
x_2=x_1-\frac{f(x_1)}{f^{'}(x_1)} \tag{3}
$$
依次计算，最终的根将无线逼近方程的解：
$$
x_{n+1}=x_n-\frac{f(x_n)}{f^{'}(x_n)} \tag{4}
$$

### 开二次方

要求常数$a$的近似解，我们可以构造函数，$f(x)=x^2-a$，$f^{'}(x)=2x$，则原来的牛顿迭代式为：
$$
\Rightarrow x_{n+1}=x_n-\frac{x^2_n-a}{2x_n}=\frac{1}{2}(x_n+a/x_n) \tag{5}
$$


给方程一个迭代初始值，$x_0=a$，然后依次迭代求得方程近似解。

==注意：==初始化为负数可能会出现负数。

### 代码

```java
public static double static sqrt(double a){
    if(a<0) return Double.NAN;
    double e=1e-7;
    double t=a;
    while(Math.abs(t*t-a)>e)
    {
        t=(a/t+t)/2.0;
    }
    return t;
}
```

### 拓展

牛顿法开$k$次方，构造函数$f(x)=x^k-a$，$f^{'}(x)=kx^{k-1}$，则牛顿迭代式为：
$$
x_{n+1}=x_n-\frac{x^k_n-a}{kx^{k-1}_n}=\frac{k-1}{k}x_n+\frac{a}{kx^{k-1}_n} \tag{6}
$$
[(1) 牛顿法](https://blog.csdn.net/lai_li/article/details/62221951)

## 优化算法

 除了经常被提起的梯度下降法，牛顿法也是机器学习中用的比较多的一种优化算法，牛顿法的速度很快，而且能高度逼近最优值。

求解优化函数$f(x)$，转化为求$f^{'}(x)=0$的解。

对$x_k$点进行泰勒展开，具体展开到二阶：
$$
f(x)=f(x_k)+f^{'}(x_k)(x-x_k)+  \frac{1}{2}f^{''}(x_k)(x-x_k)^2 \tag{7}
$$
函数两边同时对$x$求导，并令$f^{'}(x)$:
$$
f^{'}(x)=f^{'}(x_k)+f^{''}(x_k)(x-x_k)=0 \tag{8}
$$

$$
\Rightarrow x=x_k-\frac{f^{'}(x_k)}{f^{''}(x_k)} \tag{9}
$$

公式`（9）`就是牛顿迭代更新公式。